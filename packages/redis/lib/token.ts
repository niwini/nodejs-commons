//#####################################################
// Import
//#####################################################
import {
  trace,
  TraceContext,
} from "@niwini/tracer";
import dayjs from "dayjs";
import jwt from "jsonwebtoken";

import {
  RedisClient,
  IClientConfig as IRedisConfig,
} from "./client";

//#####################################################
// Types
//#####################################################

/**
 * This is the interface we need from redis client so that
 * this token manager can work properly.
 */
export interface IRedisClient {
  initialized: Promise<void>;
  get(
    key: string,
    $ctx?: TraceContext,
  ): Promise<any>;
  set(
    key: string,
    value: any,
    expTimeInSec?: number,
    $ctx?: TraceContext,
  ): Promise<string>;
  expire(
    key: string,
    expTimeInSec: number,
    $ctx?: TraceContext,
  ): Promise<number>;
}

/**
 * Interface for a jwt library.
 */
export interface IJWTClient {
  sign: (
    payload: string | object | Buffer,
    secretOrPvtKey: string,
    options: jwt.SignOptions,
    callback: (error: any, token: string) => void
  ) => void;

  verify: (
    token: string,
    secretOrPubKey: string | Buffer,
    callback: (error: any, decoded: string | object) => void
  ) => void;
}

/**
 * Interface for token manager configuration options.
 */
export interface ITokenManagerConfig {
  type?: string;
  redisIdx?: number;
  secret?: string;
  expiration?: number;
  redisConfig?: IRedisConfig;
  redisClient?: IRedisClient;
  jwtClient?: IJWTClient;
}

/**
 * Interface for token maneger exposed methods.
 */
export interface ITokenManager {
  create: (data: object, $ctx?: TraceContext) => Promise<string>;
  decode: (token: string, $ctx?: TraceContext) => Promise<object>;
  expire: (token: string, $ctx?: TraceContext) => Promise<void>;
}

//#####################################################
// Main class
//#####################################################
/**
 * This class specify a token manager.
 */
class TokenManager implements ITokenManager {
  /**
   * The client used to interact with redis db.
   */
  private _redisClient: IRedisClient;

  /**
   * The JWT client used to generate json tokens.
   */
  private _jwtClient: IJWTClient;

  /**
   * The expiration deadline time for tokens generated by this
   * manager.
   */
  private readonly _expiration: number;

  /**
   * The secret used to code and decode info into tokens.
   */
  private readonly _secret: string;

  /**
   * The type of tokens generated by this manager.
   */
  private readonly _type: string;

  /**
   * Creates an instance of TokenManager.
   *
   * @param config - A set of confit options.
   */
  constructor(config: ITokenManagerConfig = {}) {
    const WEEK_NUM_SECONDS = 24 * 60 * 60; // eslint-disable-line @typescript-eslint/no-magic-numbers

    this._expiration = config.expiration || WEEK_NUM_SECONDS;
    this._secret = config.secret || "shhhhhhh";
    this._type = config.type || "token";

    this._init(config);
  }

  /**
   * This function initializes the manager.
   *
   * @param config - A set of config options.
   * @param _$ctx - Trace context.
   */
  @trace()
  private async _init(
    config: ITokenManagerConfig,
    _$ctx?: TraceContext,
  ) {
    // Set JWT client
    this._jwtClient = config.jwtClient || jwt;

    // Set redis client
    this._redisClient = config.redisClient
      || new RedisClient(config.redisConfig);

    return this._redisClient.initialized;
  }

  /**
   * This function creates a new token.
   *
   * @param data - The data to be inserted.
   * @param $ctx - Trace context.
   */
  @trace()
  public async create(
    data: object,
    $ctx?: TraceContext,
  ): Promise<string> {
    return new Promise<string>((res, rej) => {
      this._jwtClient.sign(data, this._secret, {
        expiresIn: this._expiration,
      }, (error, token) => {
        if (error) {
          $ctx.logger.error("jwt.sign error", error);
          return rej(error);
        }

        return res(token);
      });
    });
  }

  /**
   * This function decodes a token to original object.
   *
   * @param token - The token to be decoded.
   * @param $ctx - Trace context.
   */
  @trace()
  public async decode(
    token: string,
    $ctx?: TraceContext,
  ): Promise<object> {
    $ctx.logger.debug("token to be decoded", token);

    const decoded: any = await new Promise((resolve, reject) => {
      this._jwtClient.verify(token, this._secret, (error, jwtDecoded) => {
        if (error) {
          $ctx.logger.error("jwt verify error", error);
          return reject(error);
        }

        $ctx.logger.info("jwt verify success", jwtDecoded);

        return resolve(jwtDecoded);
      });
    });

    /**
     * Check if token is not in the black list (manually expired).
     *
     * @description : JsonWebToken sucks here because it"s not possible
     * to manually expire a token. To check if a token is already
     * expired we keep a "black list" in redis.
     */
    const key = `${this._type}_${token}`;

    try {
      const result = await this._redisClient.get(key, $ctx);
      $ctx.logger.info("redis client get success", result);
    } catch (error) {
      $ctx.logger.error("redis client get error", error);
      throw error;
    }

    return decoded;
  }

  /**
   * This function expires a token (make it invalid).
   *
   * @param token - The token to be expired.
   * @param $ctx - Trace context.
   */
  @trace()
  public async expire(
    token: string,
    $ctx?: TraceContext,
  ): Promise<void> {
    try {
      await new Promise((resolve, reject) => {
        this._jwtClient.verify(token, this._secret, (error, jwtDecoded) => {
          if (error) {
            return reject(error);
          }

          $ctx.logger.info("jwt verify success", jwtDecoded);

          return resolve(jwtDecoded);
        });
      });
    } catch (error) {
      $ctx.logger.error("jwt verify error", error);

      if (error.name === "TokenExpiredError") {
        return;
      }

      throw error;
    }

    /**
     * Put token in blacklist since now it's considered invalid.
     */
    const key = `${this._type}_${token}`;

    try {
      const result = await this._redisClient.set(
        key,
        dayjs().toISOString(),
        0,
        $ctx,
      );
      $ctx.logger.info("redis client set success", result);
    } catch (error) {
      $ctx.logger.error("redis client set error", error);
      throw error;
    }

    // Remove the token from the black list after some time.
    try {
      await this._redisClient.expire(token, this._expiration);
      $ctx.logger.info("client expire success");
    } catch (error) {
      $ctx.logger.error("redis client expire error", error);
    }
  }
}

//#####################################################
// Export
//#####################################################
export {
  TokenManager as default,
};
